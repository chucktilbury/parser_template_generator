# Random Notes
These notes help me organize my thoughts.

-----------

## Another approach

The AST generated by the parser actually can be used as nodes in a finite state machine. Each node represents a state in the FSM and each terminal symbol represents a state transition (or an edge in a graph). The input to the FSM defines a path through the state machine. When there is no valid transition present, then a syntax error in the input exists. Error recovery can take place by finding a location in the FSM that allows the next valid input symbol.

Every non-terminal in a grammar can be reduced to include only states and transitions. The entire grammar can be reduced to a single FSM. Instead of backtracking input tokens, backtracking occurs with states. 

The states and transitions of the FSM can be realized by defining an array that contains the information needed to determine the next state. A state is assigned a number which is an index into the array. State transitions reference that number. 

### Generate the state machine.

The data structure is actually a heap that is represented in array form.

1. Convert each non-terminal into tree form where each non-terminal and all of it's sub-states have a unique identity. (i.e. tree heap)
2. Merge the non-terminals into a single array such that the unique identifier is the index of the node in the array.
3. Reduce the number of states by eliminating states that have exactly one reference to it, have exactly one reference to another state, and have no terminals to match.
4. Convert the tree into an array of integers as described below.


### Traverse the state machine

1. A terminal is read from the input and a search is made from the current position.
2. Push the current position on a stack.
3. If the terminal is found then another terminal is read and the search contiunes from the current position.
4. If the terminal is not found then the position is popped from the stack and the next alternative is searched.
5. If the stack becomes empty and there is a terminal symbol, then a syntax error exists in the input.

### Data structures

The FSM is an array of data structures. To implement the actual parser, this array must be able to be serialized. It can probably take the form of a clean array of unsigned integers.

```
state_number = The index of this word in the array. Used for error checking.
terminal = The terminal that this state matches. If this is zero, then always match.
match_state = The state to jump to if the terminal matches the current terminal.
no_match_state = The state to jump to if the current terminal does not match.
error_state = The state to jump to if a syntax error occoured.
// yes? no? Added by parser implementation?
void* parser_data = Data that will be passed to the action.
void parser_action(void) = Action that the parser match executes.
```

* ``state_number`` -- This is the index of the state in the array. If changing to a state and this does not match the index into the array, then that is an internal error. Somewhere the indexes got mixed up and the system does not continue.
* ``terminal`` -- This is the terminal that this state could match. If this is zero, then it is always a match. For example, this happens when the state is an entry point of a looping function.
* ``match_state`` -- This is the index of the state to jump to if the terminal symbol matches.
* ``no_match_state`` -- This is the index of the state to jump to if the terminal does not match.
* ``error_state`` -- If this is zero, then the no match state is selected. If this is not zero then it is the state to jump to to publish a syntax error and do error recovery.

***note*** The actual state information used to generate the state list will include things that are not actually part of the FSM, such as reference counts.

### Terminal table.
The first section of the array is the terminal table. Terminals may contain literal data, such as a string or a number. Also the name of the terminal is stored there to facilitate error handling.

```
state_number = Same as the FSM state
terminal_number = This is the number that is used in the FSM section of the array
data_table_index = This is the index of the data associated with the terminal.
```

The data table contains a structure somewhat like this:
```
typedef struct {
    int type;
    const char* name;
    union {
        char* str;
        double fval;
        unsigned long ival;
    } value;
} terminal_data_t;
```

Some kind of string table is needed to serialize the strings.

---------------

## AST to DFA.
This is the arching goal. To convert the input grammar into a DFA so that the parser can be generated. The input grammar consists of a list of separate named regular expressions called productions. The production are then referenced by name to construct more complicated productions. If the terminal symbols in the production matches the expression then the match "succeeded". Every reference to a terminal or non-terminal symbol can either be a match or not a match, so ultimately the tree created by the AST is a binary sub-tree.

The question is whether the terminal symbols can be built into a binary tree in such a way as to build a complete parser. If it can then that is good. If the terminal is found then then the "true" pointer points to the next possible terminal. If the terminal is not found, then it points to the "not found" symbol. Each terminal symbol has exactly 2 edges.

### OR
The true edge for an individual item points to the production found node. The false edge points to the next item in the ``or`` production. The last item false edge points to the production not found node.

### ZERO OR ONE
When the function is an item or ``zero or one`` then the false edge points to the next possible item. The true edge points to the production finished node.

### ZERO OR MORE
The true edge points back on itself. The false edge points to the production finished node.

### ONE OR MORE
The true edge points back to itself. The false edge points to a no match node.

### GROUPING
The true edge points to the production finished node. The false edge points to a no match node.

### INDIVIDUAL TERMINAL
The true edge points to the production found node and the false edge points to the production not found node.

***note*** that nodes and edges can be efficiently implemented using flexible arrays of integers.

Searching the tree for a pathway through requires backtracking of terminal symbols. An syntax error is detected if the input does not allow a path to the end of the tree. As the symbols are consumed, they are deleted. If backtracking the symbols does not allow a sub-tree to complete, then it's a syntax error from the input. In other words, all paths have been tried and there is no way to consume another terminal. The terminals that might have been consumed are "expected" and the symbol at the head of the backtrack is the "but got" symbol.

------------------

## Parser Functions
A parser function is a function that is implemented for ``PGEN``'s  input language. It is not a part of the user's grammar. The functions are used to form simple regular expressions that specify the syntax of the user's input. Every part of the input syntax to ``PGEN`` is defined by a function and the functions must be defined by the parser generator but they are not a part of the parser generators output. The parser generator's output implements a recursive parser and AST for the syntax defined by the user's grammar . 

Each parse function can be built up of state machine sections. A section corresponds to a function such as ``one or more``. A function has exactly one argument that can be another function. The exception to that is the ``grouping`` function which implements a list of arguments. Grouping always returns a list. Other functions return the type of object that they parse.

A return object can be a terminal or a non-terminal, so there needs to be a wrapper object to make them the same but still tell the difference when traversing them in the AST.

Note that tokens in this document that are formed such as ``TOK_OPAREN`` are found in the user's source code as ``'('`` and tokens that are formed such as ``OPAREN`` are a part of the parser generators syntax.

Each non-terminal has a single parsing function. While the parse function is being generated, the state number must be tracked so that it can be placed in a single switch/case statement. All parse functions have cases for match, no match, and error. All of the parse function also have a starting state.

All elements in a rule are presented in functions. A rule can be considered to be a named regular expression. All functions accept exactly one argument except the grouping function which accepts a list of arguments. The ``or`` function is right-associative. The others are left-associative.
### exactly-one
When there is a construct in the grammar such as
```
while_statement (TOK_WHILE TOK_OPAREN expression TOK_CPAREN func_block)
```
Each item is single without being a part of a function other than the group that defines the non-terminal ``while_statement``. Then there are no functions defined except the grouping. So that means that these single items must be embedded with the grouping. So that means that there will be 5 states in this function, not including the stopping states.

#### pattern
##### for a terminal
```
    case XX:
        if(token_match(TOK_WHILE)) {
            consume_the_item();
            state = whatever the next state is going to be
        }
        else
            state = STATE_NO_MATCH;
        break;
```

##### for a non-terminal
```
    case XX:
        if(NULL != (item = expression(pstate))) {
            consume_the_item();
            state = whatever the next state is going to be
        }
        else {
            // because an expression is required after "while("
            state = STATE_ERROR;
        }
        break;
```
The function generator keeps track of the states and organizes the ``case`` statements to keep them unique and correct.

### zero-or-one
Represented by the question mark (``?``) character.
#### pattern
```
// a specific item type
ast_rule_element_t* item = NULL;
...
switch(state) {
    ...
    case XX0:
        if(NULL != (item = rule_element(pstate))) {
            consume_the_item();
            state = XX1;
        }
        else
            state = STATE_NO_MATCH;
        break;
    case XX1:
        if(token_match(TOK_QUESTION)) {
            consume_the_item();
            state = STATE_MATCH;
        }
        else
            state = STATE_NO_MATCH;
        break;
    ...
}
```

### zero-or-more
Represented by the star (``*``) character.
#### pattern
```
ptr_list_t* list = NULL;
ast_rule_element_t* item = NULL;
...
switch(state) {
    ...
    case XX0:
        if(NULL != (item = rule_element(pstate))) {
            list = create_list();
            add_item_to_list(list, item);
            consume_the_item();
            state = XX1;
        }
        else
            state = STATE_NO_MATCH;
        break;
    case XX1:
        if(NULL != (item = rule_element(pstate))) {
            add_item_to_list(list, item);
            consume_the_item();
            // no state change
        }
        else if(token_match(TOK_STAR)){
            consume_the_item();
            state = STATE_MATCH;
        }
        else
            state = STATE_NO_MATCH;
        break;
    ...
}
```

### one-or-more
Represented by the plus (``+``) character.
```
ptr_list_t* list = NULL;
ast_rule_element_t* item = NULL;
...
switch(state) {
    ...
    case XX0:
        if(NULL != (item = rule_element(pstate))) {
            list = create_list();
            add_item_to_list(list, item);
            consume_the_item();
            state = XX1;
        }
        else
            state = STATE_NO_MATCH;
        break;
    case XX1:
        if(NULL != (item = rule_element(pstate))) {
            add_item_to_list(list, item);
            consume_the_item();
            // no state change
        }
        else
            state = XX2;
        break;
    case XX2:
        if(token_match(TOK_PLUS)) {
            consume_the_item();
            state = STATE_MATCH;
        }
        else
            state = STATE_NO_MATCH;
        break;
    ...
}
```

### or
Represented by the bar (``|``) character.
```
ast_rule_element_t* item = NULL;
...
switch(state) {
    ...
    case XX:
        if(NULL != (item = rule_element(pstate))) {
            consume_the_item();
            state = XX1;
        }
        else
            state = STATE_NO_MATCH;
        break;
    case XX1:
        if(token_match(TOK_BAR)) {
            consume_the_item();
            state = STATE_MATCH;
        }
        else
            state = STATE_NO_MATCH;
        break;
    ...
}

```

### grouping
Represented by parentheses ``()``.
```
ptr_list_t* list = NULL;
ast_rule_element_t* item = NULL;
...
switch(state) {
    ...
    case XX0:
        if(token_match(TOK_OPAREN)) {
            consume_the_item();
            state = XX1;
        }
        else
            state = STATE_NO_MATCH;
        break;

    case XX1:
        // first item in the group
        if(NULL != (item = rule_element(pstate))) {
            list = create_list();
            add_item_to_list(list, item);
            consume_the_item();
            state = XX2;
        }
        else
            state = STATE_ERROR;
        break;

    case XX2:
        // rest of the items in the group
        if(NULL != (item = rule_element(pstate))) {
            add_item_to_list(list, item);
            consume_the_item();
            // no state change
        }
        else 
        	state = XX3;
        break;
        
    case XX3:	      
        if(token_match(TOK_CPAREN)) {
            consume_the_item();
            state = STATE_MATCH;
        }
        else
            state = STATE_ERROR;
        break;
    ...
```

### Ending States
An ending state is one where the parsing of the current non-terminal is ending and some other action will be taken afterward.
```
  ...
  case STATE_MATCH:
      // update the output data structure.
      // consume the token queue
      // return the data structure
      break;
  case STATE_NO_MATCH:
      // reset the token queue
      // return NULL
      break;
  case STATE_ERROR:
      // reset the token queue
      // execute error recovery so parsing can continue
      // return NULL
      break;
  ...
```

## Other patterns
A rule element is what the function returns but there are al lot more patterns that a rule_element is composed of. For the grammar, a rule_element looks like this:
```
rule_element (
    NON_TERMINAL |
    TERMINAL_NAME |
    TERMINAL_SYMBOL |
    TERMINAL_OPER |
    or_function |
    one_or_more_function |
    zero_or_more_function |
    zero_or_one_function |
    grouping_function
)
```
Given this definition, the entire grammar of the parser generator can be implemented. In practice, a normal grammar will be more complicated. The patterns given above will be required to parse many non-terminals so each rule will be generated using templates.
